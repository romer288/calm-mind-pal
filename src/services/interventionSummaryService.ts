import { supabase } from '@/integrations/supabase/client';
import { InterventionSummary } from '@/types/goals';

export const interventionSummaryService = {
  async generateWeeklySummaries(): Promise<InterventionSummary[]> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    // Get anxiety analyses from the last 4 weeks (not chat messages!)
    const fourWeeksAgo = new Date();
    fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);

    const { data: analyses, error } = await supabase
      .from('anxiety_analyses')
      .select('*')
      .eq('user_id', user.id)
      .gte('created_at', fourWeeksAgo.toISOString())
      .order('created_at', { ascending: false });

    if (error) throw error;

    console.log('ğŸ“Š Found anxiety analyses:', analyses?.length || 0);

    const summaries: InterventionSummary[] = [];
    const interventionTypes = ['anxiety_management', 'mindfulness', 'coping_strategies', 'therapy_support'];
    
    // Group by weeks
    const weeks = this.groupAnalysesByWeek(analyses || []);
    console.log('ğŸ“… Grouped into weeks:', Object.keys(weeks));
    
    for (const [weekKey, weekAnalyses] of Object.entries(weeks)) {
      console.log(`ğŸ“… Processing week ${weekKey} with ${(weekAnalyses as any[]).length} analyses`);
      
      for (const interventionType of interventionTypes) {
        const relevantAnalyses = this.filterAnalysesByIntervention(weekAnalyses as any[], interventionType);
        console.log(`ğŸ¯ Found ${relevantAnalyses.length} ${interventionType} analyses for week ${weekKey}`);
        
        if (relevantAnalyses.length > 0) {
          const keyPoints = this.generateKeyPointsFromAnalyses(relevantAnalyses, interventionType);
          const [weekStart, weekEnd] = weekKey.split('_').map(date => new Date(date));
          
          const summary: InterventionSummary = {
            id: '', // Will be generated by database
            user_id: user.id,
            week_start: weekStart.toISOString().split('T')[0],
            week_end: weekEnd.toISOString().split('T')[0],
            intervention_type: interventionType,
            key_points: keyPoints.slice(0, 10), // Limit to 10 points
            conversation_count: relevantAnalyses.length,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          
          console.log('ğŸ“‹ Created summary:', summary);
          summaries.push(summary);
        }
      }
    }

    console.log('ğŸ“Š Total summaries created:', summaries.length);
    return summaries;
  },

  groupAnalysesByWeek(analyses: any[]): Record<string, any[]> {
    const weeks: Record<string, any[]> = {};
    
    analyses.forEach(analysis => {
      const analysisDate = new Date(analysis.created_at);
      const weekStart = new Date(analysisDate);
      weekStart.setDate(analysisDate.getDate() - analysisDate.getDay()); // Start of week (Sunday)
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6); // End of week (Saturday)
      
      const weekKey = `${weekStart.toISOString().split('T')[0]}_${weekEnd.toISOString().split('T')[0]}`;
      
      if (!weeks[weekKey]) {
        weeks[weekKey] = [];
      }
      weeks[weekKey].push(analysis);
    });
    
    return weeks;
  },

  filterAnalysesByIntervention(analyses: any[], interventionType: string): any[] {
    console.log(`ğŸ” Filtering ${analyses.length} analyses for intervention type: ${interventionType}`);
    
    const filtered = analyses.filter(analysis => {
      // Check if this analysis has recommended interventions that match the type
      const interventions = analysis.coping_strategies || analysis.recommendedInterventions || [];
      console.log(`ğŸ¯ Analysis ID ${analysis.id} has ${interventions.length} strategies:`, interventions);
      console.log(`ğŸ” Full analysis object:`, {
        id: analysis.id,
        coping_strategies: analysis.coping_strategies,
        recommendedInterventions: analysis.recommendedInterventions,
        anxiety_level: analysis.anxiety_level
      });
      
      switch (interventionType) {
        case 'anxiety_management':
          const isAnxietyManagement = interventions.some((strategy: string) => 
            strategy.toLowerCase().includes('breathing') ||
            strategy.toLowerCase().includes('relax') ||
            strategy.toLowerCase().includes('calm') ||
            strategy.toLowerCase().includes('anxiety') ||
            strategy.toLowerCase().includes('muscle')
          ) || analysis.anxiety_level > 0; // Include any analysis with anxiety data
          
          if (isAnxietyManagement) {
            console.log(`âœ… Including for anxiety_management: anxiety_level=${analysis.anxiety_level}, strategies=${interventions}`);
          }
          return isAnxietyManagement;
          
        case 'coping_strategies':
          const isCoping = interventions.some((strategy: string) => 
            strategy.toLowerCase().includes('coping') ||
            strategy.toLowerCase().includes('strategy') ||
            strategy.toLowerCase().includes('technique') ||
            strategy.toLowerCase().includes('grounding') ||
            strategy.toLowerCase().includes('skills') ||
            strategy.toLowerCase().includes('restructuring') ||
            strategy.toLowerCase().includes('training')
          ) || interventions.length > 0; // Include any analysis with strategies
          
          if (isCoping) {
            console.log(`âœ… Including for coping_strategies: strategies=${interventions}`);
          }
          return isCoping;
          
        case 'mindfulness':
          const isMindfulness = interventions.some((strategy: string) => 
            strategy.toLowerCase().includes('mindfulness') ||
            strategy.toLowerCase().includes('meditation') ||
            strategy.toLowerCase().includes('present') ||
            strategy.toLowerCase().includes('awareness')
          );
          
          if (isMindfulness) {
            console.log(`âœ… Including for mindfulness: strategies=${interventions}`);
          }
          return isMindfulness;
          
        case 'therapy_support':
          const isTherapy = interventions.some((strategy: string) => 
            strategy.toLowerCase().includes('therapy') ||
            strategy.toLowerCase().includes('counseling') ||
            strategy.toLowerCase().includes('professional') ||
            strategy.toLowerCase().includes('exposure') ||
            strategy.toLowerCase().includes('systematic') ||
            strategy.toLowerCase().includes('desensitization')
          ) || (analysis.personalized_response && analysis.personalized_response.length > 100); // Include analyses with detailed professional responses
          
          if (isTherapy) {
            console.log(`âœ… Including for therapy_support: strategies=${interventions}, has_response=${!!analysis.personalized_response}`);
          }
          return isTherapy;
          
        default:
          return false;
      }
    });
    
    console.log(`ğŸ“Š Filtered ${filtered.length} analyses for ${interventionType}`);
    return filtered;
  },

  generateKeyPointsFromAnalyses(analyses: any[], interventionType: string): string[] {
    const keyPoints: string[] = [];
    
    // Analyze anxiety levels
    const anxietyLevels = analyses.map(a => a.anxiety_level).filter(level => level !== null);
    if (anxietyLevels.length > 0) {
      const avgLevel = (anxietyLevels.reduce((sum, level) => sum + level, 0) / anxietyLevels.length).toFixed(1);
      keyPoints.push(`Average anxiety level: ${avgLevel}/10 across ${anxietyLevels.length} sessions`);
    }
    
    // Extract common triggers
    const allTriggers = analyses.flatMap(a => a.anxiety_triggers || []).filter(Boolean);
    const triggerCounts: { [key: string]: number } = {};
    allTriggers.forEach(trigger => {
      if (typeof trigger === 'string') {
        triggerCounts[trigger] = (triggerCounts[trigger] || 0) + 1;
      }
    });
    
    const topTriggers = Object.entries(triggerCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 3)
      .map(([trigger]) => trigger);
      
    if (topTriggers.length > 0) {
      keyPoints.push(`Main anxiety triggers: ${topTriggers.join(', ')}`);
    }
    
    // Extract common coping strategies
    const allStrategies = analyses.flatMap(a => a.coping_strategies || []).filter(Boolean);
    const strategyCounts: { [key: string]: number } = {};
    allStrategies.forEach(strategy => {
      if (typeof strategy === 'string') {
        strategyCounts[strategy] = (strategyCounts[strategy] || 0) + 1;
      }
    });
    
    const topStrategies = Object.entries(strategyCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 3)
      .map(([strategy]) => strategy);
      
    if (topStrategies.length > 0) {
      keyPoints.push(`Recommended strategies: ${topStrategies.join(', ')}`);
    }
    
    // Add intervention-specific insights
    keyPoints.push(`${analyses.length} ${interventionType.replace('_', ' ')} sessions completed`);
    
    return keyPoints.slice(0, 10);
  },

  async getUserSummaries(): Promise<InterventionSummary[]> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    const { data: summaries, error } = await supabase
      .from('intervention_summaries')
      .select('*')
      .eq('user_id', user.id)
      .order('week_start', { ascending: false });

    if (error) throw error;
    return summaries || [];
  },

  async saveSummary(summary: Omit<InterventionSummary, 'id' | 'created_at' | 'updated_at'>): Promise<InterventionSummary> {
    const { data: savedSummary, error } = await supabase
      .from('intervention_summaries')
      .insert(summary)
      .select()
      .single();

    if (error) throw error;
    return savedSummary;
  },

  async generateAndSaveSummaries(): Promise<void> {
    try {
      console.log('ğŸ”„ Starting generateAndSaveSummaries...');
      
      // Check user authentication first
      const { data: { user } } = await supabase.auth.getUser();
      console.log('ğŸ‘¤ Current user:', user?.id || 'NO USER');
      
      if (!user) {
        console.error('âŒ No authenticated user found');
        throw new Error('User not authenticated');
      }
      
      console.log('ğŸ“¡ About to call generateWeeklySummaries...');
      const summaries = await this.generateWeeklySummaries();
      console.log('ğŸ“Š Generated summaries:', summaries.length);
      console.log('ğŸ“‹ Summary details:', summaries);
      
      if (summaries.length === 0) {
        console.log('âš ï¸ No summaries generated');
        return;
      }
      
      // Save each summary to database
      for (const summary of summaries) {
        try {
          console.log('ğŸ”„ Processing summary:', {
            type: summary.intervention_type,
            week: `${summary.week_start} to ${summary.week_end}`,
            keyPoints: summary.key_points.length,
            conversationCount: summary.conversation_count
          });
          
          // Check if summary already exists for this week and intervention type
          const { data: existing } = await supabase
            .from('intervention_summaries')
            .select('id')
            .eq('user_id', summary.user_id)
            .eq('week_start', summary.week_start)
            .eq('intervention_type', summary.intervention_type)
            .single();
            
          if (!existing) {
            console.log('ğŸ’¾ Saving new summary:', summary.intervention_type, summary.week_start);
            const savedSummary = await this.saveSummary(summary);
            console.log('âœ… Successfully saved summary:', savedSummary.id);
          } else {
            console.log('â­ï¸ Summary already exists for:', summary.intervention_type, summary.week_start);
          }
        } catch (error) {
          console.error('âŒ Error saving summary:', error);
          console.error('âŒ Error details:', error);
        }
      }
      console.log('âœ… Finished generateAndSaveSummaries');
    } catch (error) {
      console.error('âŒ Error in generateAndSaveSummaries:', error);
      console.error('âŒ Error stack:', error.stack);
      throw error;
    }
  },

  async exportSummariesReport(): Promise<string> {
    const summaries = await this.getUserSummaries();
    if (summaries.length === 0) {
      return "No intervention summaries available yet. Start conversations to generate weekly summaries.";
    }

    let report = "# Weekly Intervention Summaries Report\n\n";
    report += `Generated on: ${new Date().toLocaleDateString()}\n\n`;

    // Group by intervention type
    const groupedSummaries = summaries.reduce((acc, summary) => {
      if (!acc[summary.intervention_type]) {
        acc[summary.intervention_type] = [];
      }
      acc[summary.intervention_type].push(summary);
      return acc;
    }, {} as Record<string, InterventionSummary[]>);

    for (const [interventionType, interventionSummaries] of Object.entries(groupedSummaries)) {
      report += `## ${interventionType.replace('_', ' ').toUpperCase()}\n\n`;
      
      (interventionSummaries as InterventionSummary[]).forEach(summary => {
        report += `### Week of ${summary.week_start} to ${summary.week_end}\n`;
        report += `**Conversations:** ${summary.conversation_count}\n\n`;
        report += "**Key Points:**\n";
        summary.key_points.forEach((point, index) => {
          report += `${index + 1}. ${point}\n`;
        });
        report += "\n";
      });
    }

    return report;
  }
};