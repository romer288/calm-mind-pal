import { supabase } from '@/integrations/supabase/client';
import { InterventionSummary } from '@/types/goals';

export const interventionSummaryService = {
  async generateWeeklySummaries(): Promise<InterventionSummary[]> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    // Get chat messages from the last 4 weeks
    const fourWeeksAgo = new Date();
    fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);

    const { data: messages, error } = await supabase
      .from('chat_messages')
      .select('*')
      .eq('user_id', user.id)
      .gte('created_at', fourWeeksAgo.toISOString())
      .order('created_at', { ascending: false });

    if (error) throw error;

    const summaries: InterventionSummary[] = [];
    const interventionTypes = ['anxiety_management', 'mindfulness', 'coping_strategies', 'therapy_support'];
    
    // Group by weeks
    const weeks = this.groupMessagesByWeek(messages || []);
    
    for (const [weekKey, weekMessages] of Object.entries(weeks)) {
      for (const interventionType of interventionTypes) {
        const relevantMessages = this.filterMessagesByIntervention(weekMessages, interventionType);
        if (relevantMessages.length > 0) {
          const keyPoints = this.generateKeyPoints(relevantMessages, interventionType);
          const [weekStart, weekEnd] = weekKey.split('_').map(date => new Date(date));
          
          const summary: InterventionSummary = {
            id: '', // Will be generated by database
            user_id: user.id,
            week_start: weekStart.toISOString().split('T')[0],
            week_end: weekEnd.toISOString().split('T')[0],
            intervention_type: interventionType,
            key_points: keyPoints.slice(0, 10), // Limit to 10 points
            conversation_count: relevantMessages.length,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          
          summaries.push(summary);
        }
      }
    }

    return summaries;
  },

  groupMessagesByWeek(messages: any[]): Record<string, any[]> {
    const weeks: Record<string, any[]> = {};
    
    messages.forEach(message => {
      const messageDate = new Date(message.created_at);
      const weekStart = new Date(messageDate);
      weekStart.setDate(messageDate.getDate() - messageDate.getDay()); // Start of week (Sunday)
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6); // End of week (Saturday)
      
      const weekKey = `${weekStart.toISOString().split('T')[0]}_${weekEnd.toISOString().split('T')[0]}`;
      
      if (!weeks[weekKey]) {
        weeks[weekKey] = [];
      }
      weeks[weekKey].push(message);
    });
    
    return weeks;
  },

  async getUserSummaries(): Promise<InterventionSummary[]> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    const { data: summaries, error } = await supabase
      .from('intervention_summaries')
      .select('*')
      .eq('user_id', user.id)
      .order('week_start', { ascending: false });

    if (error) throw error;
    return summaries || [];
  },

  async saveSummary(summary: Omit<InterventionSummary, 'id' | 'created_at' | 'updated_at'>): Promise<InterventionSummary> {
    const { data: savedSummary, error } = await supabase
      .from('intervention_summaries')
      .insert(summary)
      .select()
      .single();

    if (error) throw error;
    return savedSummary;
  },

  filterMessagesByIntervention(messages: any[], interventionType: string): any[] {
    const keywords: { [key: string]: string[] } = {
      anxiety_management: ['anxiety', 'panic', 'worry', 'stress', 'nervous', 'anxious', 'calm', 'relax'],
      coping_strategies: ['coping', 'strategy', 'technique', 'breathing', 'grounding', 'strategy'],
      mindfulness: ['mindfulness', 'meditation', 'present', 'awareness', 'breathing', 'focus'],
      therapy_support: ['therapy', 'therapist', 'counseling', 'treatment', 'session', 'professional']
    };

    const relevantKeywords = keywords[interventionType] || [];
    
    return messages.filter(message => 
      relevantKeywords.some(keyword => 
        message.content.toLowerCase().includes(keyword.toLowerCase())
      )
    );
  },

  generateKeyPoints(messages: any[], interventionType: string): string[] {
    // Simple keyword-based key point extraction
    const keyPoints: string[] = [];
    const userMessages = messages.filter(m => m.sender === 'user');
    const aiMessages = messages.filter(m => m.sender !== 'user');

    // Analyze patterns and generate key points
    if (userMessages.length > 0) {
      keyPoints.push(`User reported anxiety-related concerns ${userMessages.length} times this week`);
    }

    // Look for common themes
    const commonWords = this.extractCommonThemes(userMessages);
    if (commonWords.length > 0) {
      keyPoints.push(`Main topics discussed: ${commonWords.slice(0, 3).join(', ')}`);
    }

    // Check for coping strategies mentioned
    const copingMentioned = aiMessages.some(m => 
      m.content.toLowerCase().includes('breathing') || 
      m.content.toLowerCase().includes('technique') ||
      m.content.toLowerCase().includes('strategy')
    );
    
    if (copingMentioned) {
      keyPoints.push('Coping strategies and techniques were discussed');
    }

    // Check for progress indicators
    const progressWords = ['better', 'improved', 'helping', 'good', 'positive'];
    const hasProgress = userMessages.some(m => 
      progressWords.some(word => m.content.toLowerCase().includes(word))
    );
    
    if (hasProgress) {
      keyPoints.push('User reported some positive progress or improvements');
    }

    // Ensure we have at least some key points
    if (keyPoints.length === 0) {
      keyPoints.push(`${interventionType.replace('_', ' ')} discussions occurred`);
      keyPoints.push(`${messages.length} total messages exchanged`);
    }

    return keyPoints.slice(0, 10); // Max 10 key points
  },

  extractCommonThemes(messages: any[]): string[] {
    const text = messages.map(m => m.content.toLowerCase()).join(' ');
    const words = text.split(/\s+/).filter(word => word.length > 3);
    
    const wordCount: { [key: string]: number } = {};
    words.forEach(word => {
      wordCount[word] = (wordCount[word] || 0) + 1;
    });

    // Filter out common words and return most frequent
    const commonWords = ['that', 'this', 'with', 'have', 'will', 'from', 'they', 'been', 'said', 'each', 'which', 'their', 'time', 'about'];
    const themes = Object.entries(wordCount)
      .filter(([word, count]) => count > 1 && !commonWords.includes(word))
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([word]) => word);

    return themes;
  },

  async generateAndSaveSummaries(): Promise<void> {
    try {
      console.log('üîÑ Starting generateAndSaveSummaries...');
      console.log('üì° About to call generateWeeklySummaries...');
      const summaries = await this.generateWeeklySummaries();
      console.log('üìä Generated summaries:', summaries.length);
      console.log('üìã Summary details:', summaries);
      
      if (summaries.length === 0) {
        console.log('‚ö†Ô∏è No summaries generated - checking why...');
        
        // Debug: Check if we have messages
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          console.log('‚ùå No user found');
          return;
        }
        
        const fourWeeksAgo = new Date();
        fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
        
        const { data: messages, error } = await supabase
          .from('chat_messages')
          .select('*')
          .eq('user_id', user.id)
          .gte('created_at', fourWeeksAgo.toISOString());
          
        console.log('üì® Chat messages found:', messages?.length || 0);
        console.log('üì® Sample message:', messages?.[0]);
        
        if (messages && messages.length > 0) {
          const weeks = this.groupMessagesByWeek(messages);
          console.log('üìÖ Weeks found:', Object.keys(weeks));
          
          for (const [weekKey, weekMessages] of Object.entries(weeks)) {
            console.log(`üìÖ Week ${weekKey}: ${(weekMessages as any[]).length} messages`);
            const anxietyMessages = this.filterMessagesByIntervention(weekMessages, 'anxiety_management');
            console.log(`üß† Anxiety messages in ${weekKey}:`, anxietyMessages.length);
          }
        }
        
        return;
      }
      
      // Save each summary to database
      for (const summary of summaries) {
        try {
          console.log('üîÑ Processing summary:', {
            type: summary.intervention_type,
            week: `${summary.week_start} to ${summary.week_end}`,
            keyPoints: summary.key_points.length,
            conversationCount: summary.conversation_count
          });
          
          // Check if summary already exists for this week and intervention type
          const { data: existing } = await supabase
            .from('intervention_summaries')
            .select('id')
            .eq('user_id', summary.user_id)
            .eq('week_start', summary.week_start)
            .eq('intervention_type', summary.intervention_type)
            .single();
            
          if (!existing) {
            console.log('üíæ Saving new summary:', summary.intervention_type, summary.week_start);
            const savedSummary = await this.saveSummary(summary);
            console.log('‚úÖ Successfully saved summary:', savedSummary.id);
          } else {
            console.log('‚è≠Ô∏è Summary already exists for:', summary.intervention_type, summary.week_start);
          }
        } catch (error) {
          console.error('‚ùå Error saving summary:', error);
          console.error('‚ùå Error details:', error);
        }
      }
      console.log('‚úÖ Finished generateAndSaveSummaries');
    } catch (error) {
      console.error('‚ùå Error in generateAndSaveSummaries:', error);
      console.error('‚ùå Error stack:', error.stack);
      throw error;
    }
  },

  async exportSummariesReport(): Promise<string> {
    const summaries = await this.getUserSummaries();
    if (summaries.length === 0) {
      return "No intervention summaries available yet. Start conversations to generate weekly summaries.";
    }

    let report = "# Weekly Intervention Summaries Report\n\n";
    report += `Generated on: ${new Date().toLocaleDateString()}\n\n`;

    // Group by intervention type
    const groupedSummaries = summaries.reduce((acc, summary) => {
      if (!acc[summary.intervention_type]) {
        acc[summary.intervention_type] = [];
      }
      acc[summary.intervention_type].push(summary);
      return acc;
    }, {} as Record<string, InterventionSummary[]>);

    for (const [interventionType, interventionSummaries] of Object.entries(groupedSummaries)) {
      report += `## ${interventionType.replace('_', ' ').toUpperCase()}\n\n`;
      
      (interventionSummaries as InterventionSummary[]).forEach(summary => {
        report += `### Week of ${summary.week_start} to ${summary.week_end}\n`;
        report += `**Conversations:** ${summary.conversation_count}\n\n`;
        report += "**Key Points:**\n";
        summary.key_points.forEach((point, index) => {
          report += `${index + 1}. ${point}\n`;
        });
        report += "\n";
      });
    }

    return report;
  }
};